#!/bin/bash
#
# Git pre-commit hook
# 在提交前自动运行代码质量检查：format、lint、type-check
# 只检查被修改的 Python 文件
#

# 获取项目根目录
PROJECT_ROOT=$(git rev-parse --show-toplevel)
cd "$PROJECT_ROOT" || exit 1

# 检查虚拟环境是否存在
VENV="$PROJECT_ROOT/venv"
if [ ! -d "$VENV" ]; then
    echo "⚠️  警告: 虚拟环境不存在，跳过 pre-commit 检查"
    echo "提示: 运行 'make setup' 初始化项目"
    exit 0  # 允许提交，避免阻塞首次设置
fi

VENV_BIN="$VENV/bin"

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 获取暂存区中被修改的 Python 文件
STAGED_PY_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.py$' || true)

# 如果没有修改的 Python 文件，跳过检查
if [ -z "$STAGED_PY_FILES" ]; then
    echo "ℹ️  没有修改的 Python 文件，跳过检查"
    exit 0
fi

# 将文件列表转换为数组（处理包含空格的文件名）
STAGED_PY_FILES_ARRAY=()
while IFS= read -r file; do
    if [ -n "$file" ] && [ -f "$file" ]; then
        STAGED_PY_FILES_ARRAY+=("$file")
    fi
done <<< "$STAGED_PY_FILES"

# 如果没有有效的文件，跳过检查
if [ ${#STAGED_PY_FILES_ARRAY[@]} -eq 0 ]; then
    echo "ℹ️  没有有效的 Python 文件需要检查"
    exit 0
fi

echo ""
echo "🔍 运行 pre-commit 检查..."
echo "📋 检查文件: ${#STAGED_PY_FILES_ARRAY[@]} 个 Python 文件"
echo ""

# 辅助函数：添加被修改的文件到暂存区
add_staged_files() {
    local files_added=0
    for file in "${STAGED_PY_FILES_ARRAY[@]}"; do
        # 检查文件在工作区是否有修改（相对于暂存区）
        if ! git diff --quiet "$file" 2>/dev/null; then
            # 文件有修改，添加到暂存区
            if git add "$file" 2>/dev/null; then
                files_added=$((files_added + 1))
            fi
        fi
    done
    if [ $files_added -gt 0 ]; then
        return 0
    fi
    return 1
}

# 1. 格式化代码
echo "📝 步骤 1/3: 格式化代码..."
if ! command -v "$VENV_BIN/black" >/dev/null 2>&1; then
    echo "⚠️  black 未安装，跳过格式化"
else
    if "$VENV_BIN/black" "${STAGED_PY_FILES_ARRAY[@]}" 2>&1; then
        # 检查是否有文件被格式化修改
        if add_staged_files; then
            echo "📦 检测到格式化修改，已添加到暂存区"
        fi
        echo "✅ 代码格式化完成"
    else
        echo -e "${RED}❌ 格式化失败${NC}"
        exit 1
    fi
fi

# 2. 代码检查并自动修复
echo ""
echo "🔍 步骤 2/3: 代码检查并自动修复..."
if ! command -v "$VENV_BIN/ruff" >/dev/null 2>&1; then
    echo "⚠️  ruff 未安装，跳过代码检查"
else
    # 先尝试自动修复
    if "$VENV_BIN/ruff" check --fix "${STAGED_PY_FILES_ARRAY[@]}" 2>&1; then
        # 检查是否有文件被修复
        if add_staged_files; then
            echo "📦 检测到 lint 修复，已添加到暂存区"
        fi
    else
        echo -e "${YELLOW}⚠️  代码检查发现无法自动修复的问题${NC}"
    fi
    
    # 再次运行 lint 检查，确保没有剩余问题
    echo "🔍 验证代码检查..."
    if ! "$VENV_BIN/ruff" check "${STAGED_PY_FILES_ARRAY[@]}" 2>&1; then
        echo -e "${RED}❌ 代码检查失败（仍有未修复的问题）${NC}"
        echo ""
        echo "请运行以下命令查看详细错误："
        echo "  make lint"
        exit 1
    fi
    echo "✅ 代码检查完成"
fi

# 3. 类型检查
echo ""
echo "🔎 步骤 3/4: 类型检查..."
if ! command -v "$VENV_BIN/mypy" >/dev/null 2>&1; then
    echo "⚠️  mypy 未安装，跳过类型检查"
else
    if "$VENV_BIN/mypy" "${STAGED_PY_FILES_ARRAY[@]}" --ignore-missing-imports 2>&1; then
        echo "✅ 类型检查完成"
    else
        echo -e "${RED}❌ 类型检查失败${NC}"
        echo ""
        echo "请运行以下命令查看详细错误："
        echo "  make type-check"
        exit 1
    fi
fi

# 4. 运行测试
echo ""
echo "🧪 步骤 4/4: 运行测试..."
if ! command -v "$VENV_BIN/pytest" >/dev/null 2>&1; then
    echo "⚠️  pytest 未安装，跳过测试"
else
    # 尝试找到相关的测试文件
    TEST_FILES=()
    for file in "${STAGED_PY_FILES_ARRAY[@]}"; do
        # 如果修改的是测试文件本身，直接添加
        if [[ "$file" == tests/* ]]; then
            TEST_FILES+=("$file")
        else
            # 尝试找到对应的测试文件
            # 例如: app/models/llm_client.py -> tests/models/test_llm_client.py
            # 例如: app/api/chat.py -> tests/api/test_chat.py
            if [[ "$file" == app/* ]]; then
                # 获取目录和文件名
                dir=$(dirname "$file" | sed 's|^app/||')
                filename=$(basename "$file" .py)
                
                # 构建测试文件路径
                if [ -n "$dir" ] && [ "$dir" != "app" ]; then
                    test_file="tests/${dir}/test_${filename}.py"
                else
                    test_file="tests/test_${filename}.py"
                fi
                
                if [ -f "$test_file" ]; then
                    TEST_FILES+=("$test_file")
                fi
            fi
        fi
    done
    
    # 去重
    if [ ${#TEST_FILES[@]} -gt 0 ]; then
        TEST_FILES=($(printf '%s\n' "${TEST_FILES[@]}" | sort -u))
    fi
    
    # 如果有相关的测试文件，只运行这些测试；否则运行所有测试
    if [ ${#TEST_FILES[@]} -gt 0 ]; then
        echo "📋 运行相关测试文件: ${#TEST_FILES[@]} 个"
        if "$VENV_BIN/pytest" -v "${TEST_FILES[@]}" 2>&1; then
            echo "✅ 测试通过"
        else
            echo -e "${RED}❌ 测试失败${NC}"
            echo ""
            echo "请运行以下命令查看详细错误："
            echo "  make test"
            exit 1
        fi
    else
        echo "📋 未找到相关测试文件，运行所有测试..."
        if "$VENV_BIN/pytest" -v 2>&1; then
            echo "✅ 所有测试通过"
        else
            echo -e "${RED}❌ 测试失败${NC}"
            echo ""
            echo "请运行以下命令查看详细错误："
            echo "  make test"
            exit 1
        fi
    fi
fi

echo ""
echo -e "${GREEN}✅ 所有检查通过，允许提交${NC}"
echo ""
exit 0
